- 把连续性特征离散化
	- 将连续的数据进行分段，使其变为一段段离散化的区间
	- 段，bin，切分的原则有等距，等频等
- 离散化原因
	- 算法需要，比如决策树、朴素贝叶斯等算法
	- 离散化的特征更易理解
		- 比如，低薪和高薪，成绩的优良可差，合格/不合格
- 如何实现数据的离散化
	- 分组
		- 自动分组sr=pd.qcut(data, bins)
		- 自定义分组sr=pd.cut(data, [])
	- 将分组好的结果转换成 one-hot编码/独热编码/**一位有效**编码
		- pd.get_dummies(sr, prefix=)
```
# 1）准备数据
data = pd.Series([165,174,160,180,159,163,192,184], index=['No1:165', 'No2:174','No3:160', 'No4:180', 'No5:159', 'No6:163', 'No7:192', 'No8:184']) 
# No1:165    165
# No2:174    174
# No3:160    160
# No4:180    180
# No5:159    159
# No6:163    163
# No7:192    192
# No8:184    184
# dtype: int64

# 2）分组
# 自动分组
sr = pd.qcut(data, 3)
type(sr)   # pandas.core.series.Series
# No1:165      (163.667, 178.0]
# No2:174      (163.667, 178.0]
# No3:160    (158.999, 163.667]
# No4:180        (178.0, 192.0]
# No5:159    (158.999, 163.667]
# No6:163    (158.999, 163.667]
# No7:192        (178.0, 192.0]
# No8:184        (178.0, 192.0]
# dtype: category
# Categories (3, interval[float64]): [(158.999, 163.667] < (163.667, 178.0] < (178.0, 192.0]]

sr.value_counts()
# (178.0, 192.0]        3
# (158.999, 163.667]    3
# (163.667, 178.0]      2
# dtype: int64

# 3）转换成one-hot编码
pd.get_dummies(sr, prefix="height")
```
![](../photo/Pasted%20image%2020231103143701.png)

```
# 自定义分组
bins = [150, 165, 180, 195]
sr = pd.cut(data, bins)
# No1:165    (150, 165]
# No2:174    (165, 180]
# No3:160    (150, 165]
# No4:180    (165, 180]
# No5:159    (150, 165]
# No6:163    (150, 165]
# No7:192    (180, 195]
# No8:184    (180, 195]
# dtype: category
# Categories (3, interval[int64]): [(150, 165] < (165, 180] < (180, 195]]

sr.value_counts()
# (150, 165]    4
# (180, 195]    2
# (165, 180]    2
# dtype: int64

# get_dummies
pd.get_dummies(sr, prefix="身高")
```
![](../photo/Pasted%20image%2020231103143628.png)