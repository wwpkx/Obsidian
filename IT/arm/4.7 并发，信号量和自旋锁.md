# semaphore机制
- 在概念和原理上与用户态的信号量是一样的
- 是**睡眠锁**，信号量会将这个进程放入一个等待队列，然后让其睡眠。

## 方法
```
// 声明和初始化
struct semaphore sem;
void sema_init (struct semaphore *sem, int val)
void init_MUTEX (struct semaphore *sem)
void init_MUTEX_LOCKED (struct semaphore *sem)

// 获取
void down(struct semaphore * sem) 
获取信号量
不建议继续使用

int down_interruptible(struct semaphore * sem)
如果信号量不可用，进程将被置为TASK_INTERRUPTIBLE类型的睡眠状态

down_killable(struct semaphore *sem)
如果信号量不可用，进程将被置为TASK_KILLABLE类型的睡眠状态

// 释放
void up(struct semaphore * sem)
释放信号量
```

# spin_lock机制--适合于保持时间非常短的情况

## 方法
```
spin_lock_init(x)
初始化自旋锁x

spin_lock(lock)
获取自旋锁lock，
如果成功，立即获得锁，并马上返回，
否则它将一直自旋在那里，直到该自旋锁的保持者释放

spin_trylock(lock)
试图获取自旋锁lock
如果能,立即获得锁，并返回真，
否则立即返回假。它不会一直等待被释放

spin_unlock(lock)
释放自旋锁lock
它与spin_trylock或 spin_lock配对使用
```