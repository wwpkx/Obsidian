- Linux内核的整体结构非常庞大
- 方法1：把所有的组件都编译进内核文件，即：zImage或bzImage
	- 占用内存过多
- 方法2：内核模块
	- 组件被需要的时候，**动态地添加**到正在运行的内核中

# 直接编译进内核
1. 将源文件拷贝某个驱动目录
2. 修改该目录下的Kconfig，选择编译进内核
3. 修改该目录下的Makefile，指定需要依赖的.o文件

# 内核模块安装与卸载
## 加载：
- insmod hello.ko
- insmod hello.ko name=yuan age=12  #带参数
- 卸载：rmmod hello
- 查看：lsmod
- 加载(自动寻找模块依赖)：modprobe hello
modprobe会根据文件/lib/modules/version/modules.dep来查看要加载的模块，看它是否还依赖于其他模块，如果是,会先找到这些模块，把它们先加载到内核

示例
#include <linux/module.h>
#include <linux/init.h>

//模块可选信息
MODULE_LICENSE("GPL");//许可证声明
MODULE_AUTHOR("liyuan");//作者声明
MODULE_DESCRIPTION("This module is a param example.");//模块描述
MODULE_VERSION("V1.0");//模块别名
MODULE_ALIAS("a simple module");//模块别名

//模块参数
//S_IRUGO:任何用户都对/sys/module中出现的该参数具有读权限
//S_IWUSR:允许root用户修改/sys/module中出现的该参数
static char *name = "liyuan arg";
static int age = 30;
module_param(age,int,S_IRUGO);
module_param(name,charp,S_IRUGO);
 
//模块入口函数
//__init:表示代码段中的子段,里面的内容只运行一次并且回收内存.
static int __init hello_init(void)
{
    printk(KERN_EMERG "hello world!\n");
    return 0;
}

//模块卸载函数
//__exit:
static void __exit hello_exit(void)
{
    printk(KERN_EMERG "hello exit!\n");
}

//内核符号导出 函数
int add_integar(int a,int b)
{
    return a+b; 
}
int sub_integar(int a,int b)
{
    return a-b; 
}

module_init(hello_init);
module_exit(hello_exit);

//函数导出
EXPORT_SYMBOL(add_integar);
EXPORT_SYMBOL(sub_integar);
