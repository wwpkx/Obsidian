# 交叉工具链
- arm-linux-gcc
- arm-linux-ld
- arm-linux-objcopy
	- elf -> bin(2进制)
	- arm-linux-objcopy -O binary led.elf led.bin
- arm-linux-readelf
	- arm-linux-readelf -a 应用程序    可查看文件运行架构、大小端、共享库等信息。
	- arm-linux-readelf -d 应用程序    可查看应用程序的动态链接库
- arm-linux-objdump
	- 反汇编器
	- arm-linux-objdump -D led.elf > led_elf.dis

why
- 在嵌入式开发过程中有**宿主机**和**目标机**的角色之分
	- 宿主机是执行编译、链接嵌入式软件的计算机
	- 目标机是运行嵌入式软件的硬件平台  
![](../photo/Pasted%20image%2020230421103427.png)
# Makefile
- 使用GNU Make工具来管理程序
- Make能够使整个程序的编译、链接只需要一个命令(make)就可以完成
- “#”字符后的内容被视作注释。

![](../photo/Pasted%20image%2020230421115002.png)

## Makefile构成
- 规则
- 变量

## 规则
- 用于说明如何生成目标文件
- 目标 依赖 命令
```
targets : prerequisites
	command
```

### 目标
- 有多条规则，但是没有指定执行哪一条规则，make会默认执行第1条规则

### 伪目标(phony targets)
- 只包含命令，没有任何依赖的目标，称为”伪目标”(phony targets)
```
.PHONY : clean
clean : 
	rm –f hello main.o func.o
```

## 变量
- 自己定义变量
- 系统已经定义好的默认变量。
	- $^：代表所有的依赖文件
	- $@：代表目标
	- $<：代表第一个依赖文件

## 使用技巧
### 去回显
![](../photo/Pasted%20image%2020230421114551.png)

### make –f 文件名
- make命令默认在当前目录下寻找名字为makefile或者Makefile的工程文件

# 链接器脚本
![](../photo/Pasted%20image%2020230421115229.png)
```
SECTIONS {
	. = 0x30008000; /*起始链接地址*/
	
	. = ALIGN(4); 	/*对齐*/
	.text :		    /*段*/
	{
	led.o (.text)	/*代码段首文件*/
	*(.text)		
	}

	. = ALIGN(4);
	.rodata : {*(.rodata)}

	. = ALIGN(4);
	.data : {*(.data)}
	
	. = ALIGN(4);
	bss_start = .;				/*变量， .表示当前位置*/
	.bss : {*(.bss) *(COMMON)}
	bss_end = .;				/*变量， .表示当前位置*/
}
```