- 在分段机制中，线性地址即物理地址
- 无论是分段还是分页，cpu认为 **虚拟地址/线性地址**是**连续**的

## 从虚拟地址到物理地址映射
- 从寄存器中找到 **页目录/一级页表 的物理地址**，比如**cr3**、ttbrx
- 每个页表项都是4个字节，由2部分组成
	 - **指向下层页表**；根据下层页表大小 确定 需要指定的bit数
	 - 页表的其他属性
- 从虚拟地址中找到在当前页表中的位置
- 从上一层页表中的项找到下一层页表的物理地址
- **物理地址 = 最后一层页表中找到的物理地址 + 虚拟页表中的偏移量**

## x86分页机制
- 逻辑地址 --> 虚拟地址/线性地址(32位) --> 物理地址
- 线性地址：MOV eax,dword ptr ds:[0x12345678] //ds.Base+0x12345678是线性地址
- 段标识符:段内偏移量 --> 页式管理地址(10+10+12 == 页目录pde+页表pte+页内偏移量) --> 物理地址
- cr3，1级页表起始位置
- pde，page directory entry
![](../../photo/paste-1fa94926a3079b836f7f7cbbdd64fc8761319775.jpg)

## arm二级页表查询过程
![](../../photo/paste-568966199596a019a70675cb5d9f8c2c1c1980ce.jpg)
## struct page
- linux内核默认4KB，可以配置
- 对应一个struct page，该结构定义page的各种状态，比如free，lock等
![](../../photo/paste-b35dc522a5537bb0284beefb293028d8e338e859.jpg)

## 快表tlb
- 其实就是高速缓冲，目的是为了减少计算物理地址的时间
- 虚拟地址的高20位 直接映射为  物理地址的高20位
- 如果某个页被访问到，则其高20位入表
- 下次在访问该表，直接在快表中访问
- 如果，不在快表中，则通过计算获取物理地址访问
![](../../photo/paste-de80f51f6092665d2c67735457456b3e06702b33.jpg)