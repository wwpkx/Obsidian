
# 指令集
- x86
	- intel推出
	- cpu公司，intel和amd
- x64
	- x86的扩展，兼容x86

# 段寄存器
## 段寄存器有八个
- 记住**顺序：ES、CS、SS、DS、FS、GS、LDTR、TR**。
- ES：扩展段。在**串操作**时（比如 cmovs）**目标操作数的基址是 ES**，源操作数是 DS。
- CS：代码段，配合 EIP 使用。
- SS：堆栈段，凡是**基址是 EBP 或 ESP 的**，段前缀就是 SS。
- DS：数据段，**默认的都是 DS**。
- FS、GS：80386 之后定义的。

## 段寄存器定义--宽度是 96 位
struct segment { 
 word Selector; 	//16位。可见，其他不可见
 word Attributes;	//16位
 dword Base;		//32位
 dword limit;		//32位。G=0,000FFFFF=1M；G=1,FFFFFFFF=4G
}

![](../../photo/Pasted%20image%2020221206184320.png)
### 探测 Attributes
![](../../photo/Pasted%20image%2020221206185914.png)
```
int gVar; 
__asm 
{ 
	mov AX,SS //当把 SS 修改为 CS 后，程序无法正常运行
	mov DS,AX 
	mov gVar,EAX //DS:[]=EAX
					//SS:[]=EAX，通过
					//CS:[]=EAX，不通过
} 
```
### 探测 Base
![](../../photo/Pasted%20image%2020221206194546.png)
```
int Gvar; 
__asm 
{ 
	mov AX,FS//如果将 FS 改成 DS，观察程序是否正常执行
	mov GS,AX 
	mov EAX,GS:[0] 
	mov Gvar,EAX  //Gvar==0x7FFDF000
} 
```
### 探测 limit
![](../../photo/Pasted%20image%2020221206194645.png)

## 段选择子（Selector）
![](../../photo/Pasted%20image%2020221207113346.png)

## 段描述符
![](../../photo/Pasted%20image%2020221207195838.png)

![](../../photo/Pasted%20image%2020221207095404.png)
### Type
![](../../photo/Pasted%20image%2020221207111918.png)

![](../../photo/Pasted%20image%2020221207112039.png)

# 权限
- cpl 【cs的值】 cpu当前的权限级别
- dpl 【段描述符中】 你要访问我，要具备的权限
- rpl 【段选择子中】 用什么权限去访问一个段。因为在段选择子中，可以随便赋值

## 为什么有rpl？
- 可以**用读写权限打开**文件
- 可以**用只读权限**打开文件

## 数据段权限检查
- cpl<=dpl && rpl<=dpl （数值的比较）
- **权限大**就能访问

## 代码段权限检查
- 一致代码段/共享段（一般为内核段）。cpl>=dpl //**小权限（用户态）** 才能访问
- 非一致代码段/普通代码段。cpl == dpl && rpl<=dpl //**同级**访问
- cpl不会改变

# 代码调用
- - 跨段调用时，一旦有权限切换，就会切换堆栈
- CS的权限一旦改变，SS的权限也要随着改变，**CS与SS的特权级别必须一致**（INTEL定义的规则）
- JMP FAR 只能跳转到**同级代码段**（非一致代码段/普通代码段）
- CALL FAR可以通过调用门进行提权（提升CPL的权限）

## 加载段描述符至段寄存器
- 可以使用les，lss，lds，lfs，lgs修改寄存器
- 要改cs，必须保证cs和eip一致
	- jmp far/call far/retf/int/ireted
- 只修改eip。jmp/call/jcc/ret 

## jmp far例子
jmp 0x20:0x004183d7。执行该语句，会经历一下流程
```
四种情况可跳转（描述符类型S）
- s=0，调用门，tss任务段，任务门
- s=1，代码段（只能是同级代码段）

分析段选择子
0x20: 0000 0000 0010 0000
rpl=0，内核态
ti=0,查gdt表
index=4，找到段描述符（从0开始计算）

权限检查
- cpl（cs中），rpl（在段选择子中），dpl（在段描述符中）
- 一致代码段/共享段（一般为内核段）。cpl>=dpl //**小权限（用户态）** 才能访问
- 非一致代码段/普通代码段。cpl == dpl && rpl<=dpl //**同级**访问

改变cs和eip
cs: cpu将段描述符加载到cs段寄存器中
eip = cs.base+offset
```

## 短调用
![](../../photo/Pasted%20image%2020221207175703.png)

## 长调用（跨段不提权）
![](../../photo/Pasted%20image%2020221207182823.png)

![](../../photo/Pasted%20image%2020221207205603.png)

## 长调用（跨段并提权）
![](../../photo/Pasted%20image%2020221207183517.png)

![](../../photo/Pasted%20image%2020221207220637.png)
