# I/O 多路复用 
```
io多路复用概念
- 一个进程同时监听多个打开的文件描述符，一旦某个文件描述符就绪，就立即通知程序进行相应的读写操作
- 比如，一个进程监控鼠标、键盘、摄像头等

函数说明
int poll(struct pollfd *fds, nfds_t nfds, int timeout);  //用户空间调用
- fds，要监听的文件描述符集合
- nfds，要监听的文件描述符个数
- timeout，超时时间
    INFTIM    永远等待
    0     立即返回，不阻塞进程
    >0 等待指定数目的毫秒数

struct pollfd {
    int fd;          //打开的文件节点
    short events;    //请求检测的事件
    short revents;   //检测之后返回的事件
};

事件
- POLLIN    普通或优先级带数据可读
- POLLRDNORM    普通数据可读
- POLLRDBAND    优先级带数据可读
- POLLPRI    高优先级数据可读
+ POLLOUT    普通或优先级数据可写
+ POLLWRNORM    普通数据可写
+ POLLWRBAND    优先级带数据可写
= POLLERR    发生错误
= POLLHUP    发生挂起
= POLLNVAL    描述字不是一个打开的文件


代码示例 -- 驱动
//从设备信息
struct MyDemoDevice {
    char name[64];
    wait_queue_head_t read_queue;
    wait_queue_head_t write_queue;    
    struct kfifo mydemo_fifo;
};

static struct MyDemoDevice *mydemo_device[8];  //8个从设备信息数组
static const struct file_operations demodrv_fops = { //从设备操作函数集合
    .owner = THIS_MODULE,
    .open = demodrv_open,
    .release = demodrv_release,
    .read = demodrv_read,
    .write = demodrv_write,
    .poll = demodrv_poll,
};

__init 函数
//创建了8个从设备，从设备号0--7
ret = alloc_chrdev_region(&dev, 0, 8, "mydemo_dev");  //dev_t dev;返回主从设备号 
static struct cdev *demo_cdev = cdev_alloc();
cdev_init(demo_cdev, &demodrv_fops);
ret = cdev_add(demo_cdev, dev, 8);    //添加8个从设备
for (i = 0; i < 8; i++) {
    //新建从设备信息
    struct MyDemoDevice *device = kmalloc(sizeof(struct MyDemoDevice), GFP_KERNEL);
    mydemo_device[i] = device;
    sprintf(device->name, "%s%d", "mydemo_dev", i);  //设置从设备名字
    //设置读写等待队列
    init_waitqueue_head(&device->read_queue);
    init_waitqueue_head(&device->write_queue);
    //设置从设备需要的fifo缓冲区
    ret = kfifo_alloc(&device->mydemo_fifo, 64, GFP_KERNEL);
}
    
//打开从设备时，把从设备信息和file->private_data关联起来
static int demodrv_open(struct inode *inode, struct file *file)
{
    unsigned int minor = iminor(inode);        //从设备号
    struct MyDemoDevice *device = mydemo_device[minor]; //获取从设备信息
    file->private_data = device;
    return 0;
}

// 读取从设备。读写操作类似
static ssize_t demodrv_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
{
。。。
    struct MyDemoDevice *device = file->private_data;  //获取从设备信息
    if (kfifo_is_empty(&device->mydemo_fifo)) {    //缓冲空了
        if (file->f_flags & O_NONBLOCK)  //非阻塞模式处理
            return -EAGAIN;

        //阻塞模式处理
        //缓冲空，进入读等待队列。如果不空了，自己唤醒自己
        ret = wait_event_interruptible(device->read_queue,!kfifo_is_empty(&device->mydemo_fifo));
        if (ret)    //如果出错，则返回错误码
            return ret;
    }

    ret = kfifo_to_user(&device->mydemo_fifo, buf, count, &actual_readed);
    if (ret)
        return -EIO;

    // 如果缓冲不满，唤醒写队列
    if (!kfifo_is_full(&device->mydemo_fifo))
        wake_up_interruptible(&device->write_queue);
        
    return actual_readed;
}

//io多路复用，使用与poll和select
static unsigned int demodrv_poll(struct file *file, poll_table *wait)
{
    int mask = 0;
    struct MyDemoDevice *device = file->private_data;

    poll_wait(file, &device->read_queue, wait);
    poll_wait(file, &device->write_queue, wait);

    if (!kfifo_is_empty(&device->mydemo_fifo))
        mask |= POLLIN | POLLRDNORM;
    if (!kfifo_is_full(&device->mydemo_fifo))
        mask |= POLLOUT | POLLWRNORM;
    
    return mask;
}

示例代码 -- 测试代码 -- 用户空间
int main(int argc, char *argv[])
{
。。。
    struct pollfd fds[2];
    fds[0].fd = open("/dev/mydemo0", O_RDWR);
    fds[0].events = POLLIN;  // events，要监听读事件

    fds[1].fd = open("/dev/mydemo1", O_RDWR);
    fds[1].events = POLLIN;

    while (1) {
        ret = poll(fds, 2, -1);
        if (fds[0].revents & POLLIN) {  //revents，实际发生的事件
            ret = read(fds[0].fd, buffer0, sizeof(buffer0));
            printf("%s\n", buffer0);
        }

        if (fds[1].revents & POLLIN) {
            ret = read(fds[1].fd, buffer1, sizeof(buffer1));
            printf("%s\n", buffer1);
        }
    }
。。。
}
```
