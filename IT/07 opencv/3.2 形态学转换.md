# 总结
连通性 
- 邻接关系：4邻接，8邻接和D邻接
- 连通性：4连通，8连通和m连通

形态学操作
- 腐蚀和膨胀：
	- 腐蚀：求局部最大值
	- 膨胀：求局部最小值
- 开闭运算：
	- 开：先腐蚀后膨胀
	- 闭：先膨胀后腐蚀
- 礼帽和黑帽：
	- 礼帽：原图像与开运算之差
	- 黑帽：闭运算与原图像之差

# 1 连通性
- 在图像中，最小的单位是像素
- 每个像素周围有8个邻接像素
- **邻接关系**有3种：4邻接、8邻接和D邻接
- **连通性**
	- 描述区域和边界的重要概念
	- 根据连通性的定义，有4联通、8联通和m联通三种
	- 必要条件
		1. 两个像素的位置**是否相邻**
		2. **两个像素的灰度值** 是否满足 **特定的相似性准则（或者是否相等)**

![](../photo/Pasted%20image%2020240119180324.png)
![](../photo/Pasted%20image%2020240119182053.png)

# 2 形态学操作
- 形态学转换是**基于图像形状**的一些简单操作。
- 它通常在**二进制图像**上执行。
- 腐蚀和膨胀是两个基本的形态学运算符。
- 它的变体形式如开运算，闭运算，礼帽，黑帽等。

## 2.1 腐蚀和膨胀
- 腐蚀和膨胀是最基本的形态学操作，
- 腐蚀和膨胀都是**针对白色部分（二进制图像只有黑白）**而言的。
- **腐蚀**是原图中的**高亮区域被蚕食**
	- **作用**是消除物体边界点，使目标缩小，可以**消除小于结构元素的噪声点**。
- **膨胀**就是使图像中**高亮部分扩张**

**示例**
我们使用一个5x5的卷积核实现腐蚀和膨胀的运算：
```
import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt

# 1 读取图像
img = cv.imread("./image/image3.png")
# 2 创建核结构
kernel = np.ones((5, 5), np.uint8)

# 3 图像腐蚀和膨胀
erosion = cv.erode(img, kernel) # 腐蚀
dilate = cv.dilate(img,kernel) # 膨胀

# 4 图像展示
fig,axes=plt.subplots(nrows=1,ncols=3,figsize=(10,8),dpi=100)
axes[0].imshow(img)
axes[0].set_title("原图")
axes[1].imshow(erosion)
axes[1].set_title("腐蚀后结果")
axes[2].imshow(dilate)
axes[2].set_title("膨胀后结果")
plt.show()
```
![](../photo/Pasted%20image%2020240119195504.png)
### 腐蚀
腐蚀操作步骤   
1. 用一个结构元素扫描图像中的每一个像素
2. 用结构元素中的每一个像素与其覆盖的像素做**与操作**
3. 如果**都为1**，则该像素为1，否则为0
	- 特别注意，匹配了所有结构元素，这个扫描点才为1
![](../photo/Pasted%20image%2020240119194622.png)

腐蚀API     
```
cv.erode(img,kernel,iterations)
参数：
- img: 要处理的图像
- kernel: 核结构
- iterations: 腐蚀的次数，默认是1
```
### 膨胀
膨胀操作步骤   
- 用一个结构元素扫描图像中的每一个像素
- 用结构元素中的每一个像素与其覆盖的像素做**或操作**
- 如果都为0，则该像素为0，否则为1
![](../photo/Pasted%20image%2020240119195314.png)

膨胀API     
```
cv.dilate(img,kernel,iterations)
参数：
- img: 要处理的图像
- kernel: 核结构
- iterations: 腐蚀的次数，默认是1
```

## 2.2 开闭运算
- 开运算是**先腐蚀后膨胀**
- 开运算和闭运算是**将腐蚀和膨胀按照一定的次序**进行处理
- 但这**两者并不是可逆的**，即先开后闭并不能得到原来的图像

```
cv.morphologyEx(img, op, kernel)
参数：
img: 要处理的图像
op: 处理方式
- 开运算，则设为cv.MORPH_OPEN；
- 闭运算，则设为cv.MORPH_CLOSE
Kernel： 核结构
```

**示例**: 使用10x10的核结构对卷积进行开闭运算的实现。
```
import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
# 1 读取图像
img1 = cv.imread("./image/image5.png")
img2 = cv.imread("./image/image6.png")
# 2 创建核结构
kernel = np.ones((10, 10), np.uint8)
# 3 图像的开闭运算
cvOpen = cv.morphologyEx(img1,cv.MORPH_OPEN,kernel) # 开运算
cvClose = cv.morphologyEx(img2,cv.MORPH_CLOSE,kernel)# 闭运算
# 4 图像展示
fig,axes=plt.subplots(nrows=2,ncols=2,figsize=(10,8))
axes[0,0].imshow(img1)
axes[0,0].set_title("原图")
axes[0,1].imshow(cvOpen)
axes[0,1].set_title("开运算结果")
axes[1,0].imshow(img2)
axes[1,0].set_title("原图")
axes[1,1].imshow(cvClose)
axes[1,1].set_title("闭运算结果")
plt.show()
```
![](../photo/Pasted%20image%2020240122115205.png)
### **开运算**
- **作用**是：分离物体，消除小区域
- **特点**：消除噪点，去除小的干扰块，而不影响原来的图像。

![](../photo/Pasted%20image%2020240122114919.png)

### **闭运算**
- 是**先膨胀后腐蚀**
- **作用**是消除/“闭合”物体里面的孔洞
- **特点**：可以填充闭合区域

![](../photo/Pasted%20image%2020240122115020.png)

### 2.3 礼帽和黑帽
